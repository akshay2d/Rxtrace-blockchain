import { NextResponse } from 'next/server';
import { supabaseServer } from '@/lib/supabase/server';
import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { ensureActiveBillingUsage } from '@/lib/billing/usage';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

function toNumber(value: unknown): number {
  if (typeof value === 'number') return value;
  if (typeof value === 'bigint') return Number(value);
  const n = Number(value);
  return Number.isFinite(n) ? n : 0;
}

export async function GET() {
  try {
    // Route handlers run server-side; use SSR client for auth cookies.
    const {
      data: { user },
      error: authError,
    } = await (await supabaseServer()).auth.getUser();

    if (!user || authError) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Use admin client for data reads to avoid RLS friction.
    const supabase = getSupabaseAdmin();

    const { data: company, error: companyError } = await supabase
      .from('companies')
      .select('id, company_name')
      .eq('user_id', user.id)
      .maybeSingle();

    if (companyError) {
      return NextResponse.json({ error: companyError.message }, { status: 500 });
    }

    if (!company?.id) {
      return NextResponse.json({ error: 'Company not found' }, { status: 404 });
    }

    const companyId = company.id as string;

    // Billing usage (current trial/paid period): used label quotas are the most accurate
    // “realtime generation” counters because they are incremented atomically during create APIs.
    const activeUsage = await ensureActiveBillingUsage({ supabase, companyId }).catch((err) => {
      console.error('Failed to ensure active billing usage:', err);
      return null;
    });

    // Total SKUs
    const { count: totalSkus, error: skuErr } = await supabase
      .from('skus')
      .select('id', { count: 'exact', head: true })
      .eq('company_id', companyId)
      .is('deleted_at', null);

    if (skuErr) {
      return NextResponse.json({ error: skuErr.message }, { status: 500 });
    }

    // Units generated (best-effort): sum(total_strips) from generation_jobs.
    // If you use a different “formula” in Supabase (view/RPC), we can swap this.
    const { data: jobs, error: jobsErr } = await supabase
      .from('generation_jobs')
      .select('total_strips')
      .eq('company_id', companyId);

    if (jobsErr) {
      return NextResponse.json({ error: jobsErr.message }, { status: 500 });
    }

    const unitsGenerated = (jobs ?? []).reduce((acc, row) => acc + toNumber((row as any).total_strips), 0);

    // SSCC generated: pallets count
    const { count: ssccGenerated, error: palletsErr } = await supabase
      .from('pallets')
      .select('id', { count: 'exact', head: true })
      .eq('company_id', companyId);

    if (palletsErr) {
      return NextResponse.json({ error: palletsErr.message }, { status: 500 });
    }

    // Total scans (company scans only)
    const { count: totalScans, error: scansErr } = await supabase
      .from('scan_logs')
      .select('id', { count: 'exact', head: true })
      .eq('company_id', companyId);

    if (scansErr) {
      return NextResponse.json({ error: scansErr.message }, { status: 500 });
    }

    // Scan breakdown by expiry status (CRITICAL BLOCKER FIX)
    const { data: scanLogs, error: scanLogsErr } = await supabase
      .from('scan_logs')
      .select('metadata, status')
      .eq('company_id', companyId);

    if (scanLogsErr) {
      console.warn('Could not fetch scan breakdown:', scanLogsErr.message);
    }

    const validProductScans = (scanLogs || []).filter(log => {
      const expiryStatus = log.metadata?.expiry_status;
      return expiryStatus === 'VALID' || (!expiryStatus && log.status === 'SUCCESS');
    }).length;

    const expiredProductScans = (scanLogs || []).filter(log => {
      const expiryStatus = log.metadata?.expiry_status;
      return expiryStatus === 'EXPIRED' || (log.metadata?.error_reason === 'PRODUCT_EXPIRED');
    }).length;

    const duplicateScans = (scanLogs || []).filter(log => {
      return log.metadata?.status === 'DUPLICATE';
    }).length;

    const errorScans = (scanLogs || []).filter(log => {
      return log.status === 'ERROR' || log.status === 'FAILED';
    }).length;

    // Active handsets
    const { count: activeHandsets, error: handsetsErr } = await supabase
      .from('handsets')
      .select('id', { count: 'exact', head: true })
      .eq('company_id', companyId)
      .eq('status', 'ACTIVE');

    if (handsetsErr) {
      return NextResponse.json({ error: handsetsErr.message }, { status: 500 });
    }

    // Active seats
    const { count: activeSeats, error: seatsErr } = await supabase
      .from('seats')
      .select('id', { count: 'exact', head: true })
      .eq('company_id', companyId)
      .eq('active', true);

    if (seatsErr) {
      return NextResponse.json({ error: seatsErr.message }, { status: 500 });
    }

    // Recent activity from audit_logs (last 10 entries)
    const { data: recentActivity, error: activityErr } = await supabase
      .from('audit_logs')
      .select('id, action, status, details, created_at')
      .eq('company_id', companyId)
      .order('created_at', { ascending: false })
      .limit(10);

    if (activityErr) {
      console.warn('Could not fetch recent activity:', activityErr.message);
    }

    return NextResponse.json({
      company_id: companyId,
      company_name: company.company_name ?? null,
      total_skus: totalSkus ?? 0,
      units_generated: unitsGenerated,
      sscc_generated: ssccGenerated ?? 0,
      total_scans: totalScans ?? 0,
      active_handsets: activeHandsets ?? 0,
      active_seats: activeSeats ?? 0,
      scan_breakdown: {
        valid_product_scans: validProductScans,
        expired_product_scans: expiredProductScans,
        duplicate_scans: duplicateScans,
        error_scans: errorScans,
      },
      label_generation: {
        unit: activeUsage ? toNumber((activeUsage as any).unit_labels_used) : 0,
        box: activeUsage ? toNumber((activeUsage as any).box_labels_used) : 0,
        carton: activeUsage ? toNumber((activeUsage as any).carton_labels_used) : 0,
        pallet: activeUsage ? toNumber((activeUsage as any).pallet_labels_used) : 0,
      },
      recent_activity: recentActivity ?? [],
    });
  } catch (err: any) {
    return NextResponse.json({ error: err?.message || String(err) }, { status: 500 });
  }
}
